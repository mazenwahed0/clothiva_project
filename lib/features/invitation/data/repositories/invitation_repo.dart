// lib/features/invitation/data/repositories/invitation_repo.dart

import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/invitation_model.dart';
import 'package:firebase_auth/firebase_auth.dart';

class InvitationRepository {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;

  CollectionReference get _invitationsCollection =>
      _firestore.collection('invitations');

  // Getter for the current authenticated user
  User? get _currentUser => _auth.currentUser;

  // Function to send a new invitation
  Future<void> sendInvite(String email) async {
    if (_currentUser == null) {
      throw Exception("User is not logged in.");
    }

    final newInvitation = Invitation(
      id: '', // ID will be generated by Firestore
      senderId: _currentUser!.uid,
      senderName:
          _currentUser!.displayName ?? 'Unknown User', // Use the display name
      recipientEmail: email.toLowerCase().trim(),
      status: InvitationStatus.pending,
      createdAt: DateTime.now(),
      shareEnabled: true, // Default: sharing is enabled upon invite
    );

    // Add the invitation document to the 'invitations' collection
    await _invitationsCollection.add(newInvitation.toMap());
  }

  // Function to fetch pending invitations directed to the current user (for Accept/Reject screen)
  Stream<List<Invitation>> fetchPendingInvitations() {
    final userEmail = _currentUser?.email;
    if (userEmail == null) {
      return Stream.value([]);
    }

    return _invitationsCollection
        .where('recipientEmail', isEqualTo: userEmail.toLowerCase().trim())
        .where(
          'status',
          isEqualTo: InvitationStatus.pending.toString().split('.').last,
        )
        .snapshots()
        .map((snapshot) {
          return snapshot.docs
              .map((doc) => Invitation.fromFirestore(doc))
              .toList();
        });
  }

  // Function to fetch accepted collaborators (users who are sharing or being shared with)
  Stream<List<Invitation>> fetchCollaborators() {
    final currentUserId = _currentUser?.uid;
    if (currentUserId == null) {
      return Stream.value([]);
    }

    // Fetch accepted invitations where the current user is either the sender OR the recipient
    return _invitationsCollection
        .where(
          'status',
          isEqualTo: InvitationStatus.accepted.toString().split('.').last,
        )
        .where(
          // Firestore OR query to check if the user is involved in the collaboration
          Filter.or(
            Filter('senderId', isEqualTo: currentUserId),
            Filter('recipientId', isEqualTo: currentUserId),
          ),
        )
        .snapshots()
        .map((snapshot) {
          return snapshot.docs
              .map((doc) => Invitation.fromFirestore(doc))
              .toList();
        });
  }

  // Function to accept an invitation
  Future<void> acceptInvite(String inviteId) async {
    if (_currentUser == null) {
      throw Exception("User is not logged in.");
    }

    await _invitationsCollection.doc(inviteId).update({
      'status': InvitationStatus.accepted.toString().split('.').last,
      'recipientId':
          _currentUser!.uid, // Register the UID of the accepting user
    });
  }

  // Function to reject an invitation (changes its status)
  Future<void> rejectInvite(String inviteId) async {
    await _invitationsCollection.doc(inviteId).update({
      'status': InvitationStatus.rejected.toString().split('.').last,
      // Optional: Log the rejection by adding a 'rejectedAt' field.
    });
  }

  // Function to update the share status (ON/OFF Switch)
  Future<void> updateShareStatus(String inviteId, bool isEnabled) async {
    await _invitationsCollection.doc(inviteId).update({
      'shareEnabled': isEnabled,
    });
  }

  // Fetch invitations I have sent
  Stream<List<Invitation>> fetchSentInvitations() {
    final currentUserId = _currentUser?.uid;
    if (currentUserId == null) return Stream.value([]);

    return _invitationsCollection
        .where('senderId', isEqualTo: currentUserId)
        .snapshots()
        .map(
          (snapshot) => snapshot.docs
              .map((doc) => Invitation.fromFirestore(doc))
              .toList(),
        );
  }
}
